#!/bin/bash
#===============================================================================
# FILE:         functions.sh
#
# USAGE:        Include in other scripts, e.g. source functions.sh
#
# DESCRIPTION:  Defines but does not execute functions that can be used
#               in other scripts.
#===============================================================================

# Treat unset variables as an error when peforming parameter expansion
# Exit immediately on errors
set -o nounset errexit

#-------------------------------------------------------------------------------
# Basic functions
#-------------------------------------------------------------------------------

# Requires:
#   LOG_FILE
log()
{
    # Use msg with prefix to distinguish logs generated by setup scripts
    local msg="log: $@"

    # Write message to screen and log file
    (echo "$msg" 2>&1) | tee -a $LOG_FILE
    return ${PIPESTATUS[0]}
}

# Requires:
#   LOG_FILE
cmd()
{
    # Record command to be executed to the log file
    echo "cmd: $@" >> $LOG_FILE

    # Execute command
    # Redirect stdout and stderr to screen and log file
    (eval "$@" 2>&1) | tee -a $LOG_FILE
    return ${PIPESTATUS[0]}
}

# Terminates the script when provided error code is nonzero
# Usage: err "$?" "$FUNCNAME" "message to be shown and logged"
err()
{
    local error="$1"
    local funcname="$2"
    local msg="$3"

    if [[ "$error" -ne 0 ]]; then
        log "$funcname: $msg: $error"
        log "Aborting!"
        exit 1
    fi
}

uncommentVar()
{
    local var="$1"
    local file="$2"

    cmd "sed -i \"s|^#\(${var}.*\)$|\1|\" ${file}"
}

commentVar()
{
    local var="$1"
    local file="$2"

    cmd "sed -i \"s|^\(${var}.*\)$|#\1|\" ${file}"
}

#-------------------------------------------------------------------------------
# Composite functions
#-------------------------------------------------------------------------------

installPackage()
{
    log "Install package $@..."
    cmd "pacman -S $@ --noconfirm"
    err "$?" "$FUNCNAME" "failed to install package"
    log "Install package $@...done"
}

checkPartitionsCount()
{
    local hdd=$1
    local cnt=$2
    local lines=$(lsblk $hdd | wc -l)
    local ptns=$(($lines - 2))
    local ret=0

    if [[ "$cnt" -ne "$ptns" ]]; then
        log "Expected:$cnt; found:$ptns"
        ret=1
    fi

    return $ret
}

createPartition()
{
    local disk="$1"         # e.g. /dev/sda
    local partType="$2"     # "p" for prtimary, "e" for extented
    local partNb="$3"       # e.g. "1" for "/dev/sda1"
    local partSize="$4"     # e.g. "+1G" for 1GiB, "" for remaining space
    local partCode="$5"     # e.g. "82" for swap, "83" for Linux, etc.
    local partCodeNb=""     # No partition nb for code setting for 1st partition

    # For first partition, provide partition number when entering
    # partition code
    if [[ $partNb -ne 1 ]]; then
        partCodeNb=$partNb
    fi

    cat <<-EOF | fdisk $disk
	n
	$partType
	$partNb
	
	$partSize
	t
	$partCodeNb
	$partCode
	w
	EOF

    err "$?" "$FUNCNAME" "failed to create partition"
}

# Best executed when all (at least two) partitions are created
setPartitionBootable()
{
    local disk="$1"     # e.g. /dev/sda
    local partNb="$2"   # e.g. "1" for "/dev/sda1"

    cat <<-EOF | fdisk $disk
	a
	$partNb
	w
	EOF

    err "$?" "$FUNCNAME" "failed to set partition bootable"
}

downloadFile()
{
    local src=$1
    local dst=$2

    cmd "curl -so $dst --create-dirs $src"
    err "$?" "$FUNCNAME" "failed to download file"
}

