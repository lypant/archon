#!/bin/bash
#===============================================================================
# FILE:         functions.sh
#
# USAGE:        Include in other scripts, e.g. source functions.sh
#
# DESCRIPTION:  Defines but does not execute functions that can be used
#               in other scripts.
#===============================================================================

# Treat unset variables as an error when peforming parameter expansion
# Exit immediately on errors
set -o nounset -o errexit

#-------------------------------------------------------------------------------
# Basic functions
#-------------------------------------------------------------------------------

# Requires:
#   LOG_FILE
log()
{
    # Use msg with prefix to distinguish logs generated by setup scripts
    local msg="log: $@"

    # Write message to screen and log file
    (echo "$msg" 2>&1) | tee -a $LOG_FILE
    return ${PIPESTATUS[0]}
}

# Requires:
#   LOG_FILE
cmd()
{
    # Record command to be executed to the log file
    echo "cmd: $@" >> $LOG_FILE

    # Execute command
    # Redirect stdout and stderr to screen and log file
    (eval "$@" 2>&1) | tee -a $LOG_FILE
    return ${PIPESTATUS[0]}
}

# Terminates the script when provided error code is nonzero
# Usage: err "$?" "$FUNCNAME" "message to be shown and logged"
err()
{
    local error="$1"
    local funcname="$2"
    local msg="$3"

    if [[ "$error" -ne 0 ]]; then
        log "$funcname: $msg: $error"
        log "Aborting!"
        exit 1
    fi
}

uncommentVar()
{
    local var="$1"
    local file="$2"

    cmd "sed -i \"s|^#\(${var}.*\)$|\1|\" ${file}"
}

commentVar()
{
    local var="$1"
    local file="$2"

    cmd "sed -i \"s|^\(${var}.*\)$|#\1|\" ${file}"
}

#-------------------------------------------------------------------------------
# Composite functions
#-------------------------------------------------------------------------------

installPackage()
{
    log "Install package $@..."
    cmd "pacman -S $@ --noconfirm"
    err "$?" "$FUNCNAME" "failed to install package"
    log "Install package $@...done"
}

removePackage()
{
    log "Remove package $@..."
    cmd "pacman -Rdd $@ --noconfirm"
    err "$?" "$FUNCNAME" "failed to remove package"
    log "Remove package $@...done"
}

checkPartitionsCount()
{
    local hdd=$1
    local cnt=$2
    local lines=$(lsblk $hdd | wc -l)
    local ptns=$(($lines - 2))
    local ret=0

    if [[ "$cnt" -ne "$ptns" ]]; then
        log "Expected:$cnt; found:$ptns"
        ret=1
    fi

    return $ret
}

createPartition()
{
    local disk="$1"         # e.g. /dev/sda
    local partType="$2"     # "p" for prtimary, "e" for extented
    local partNb="$3"       # e.g. "1" for "/dev/sda1"
    local partSize="$4"     # e.g. "+1G" for 1GiB, "" for remaining space
    local partCode="$5"     # e.g. "82" for swap, "83" for Linux, etc.
    local partCodeNb=""     # No partition nb for code setting for 1st partition

    # For first partition, provide partition number when entering
    # partition code
    if [[ $partNb -ne 1 ]]; then
        partCodeNb=$partNb
    fi

    cat <<-EOF | fdisk $disk
	n
	$partType
	$partNb
	
	$partSize
	t
	$partCodeNb
	$partCode
	w
	EOF

    # TODO: Try to find more universal solution
    # sync and partprobe did not work to avoid following report:
    # Re-reading the partition table failed: Device or resource busy
    sleep 5

    err "$?" "$FUNCNAME" "failed to create partition"
}

# Best executed when all (at least two) partitions are created
setPartitionBootable()
{
    local disk="$1"     # e.g. /dev/sda
    local partNb="$2"   # e.g. "1" for "/dev/sda1"

    cat <<-EOF | fdisk $disk
	a
	$partNb
	w
	EOF

    err "$?" "$FUNCNAME" "failed to set partition bootable"
}

downloadFile()
{
    local src=$1
    local dst=$2

    cmd "curl -LSso $dst --create-dirs $src"
    err "$?" "$FUNCNAME" "failed to download file"
}

archChroot()
{
    cmd arch-chroot /mnt /bin/bash -c \""$@"\"
}

setLocale()
{
    local subst="s|^#\\\\\(${1}.*\\\\\)$|\1|"
    local file="/etc/locale.gen"

    log "Set locale for  $1..."
    archChroot "sed -i \\\"$subst\\\" $file"
    err "$?" "$FUNCNAME" "failed to set locale"
    log "Set locale for $1...done"
}

createLink()
{
    local linkTarget=$1
    local linkName=$2
    local retval=0

    if [[ -e $linkTarget ]]; then
        cmd "ln -s $linkTarget $linkName"
        retval=$?
    else
        log "Link target does not exist!"
        retval=1
    fi

    return $retval
}

createDir()
{
    local dir="$1"
    local retval=0

    # Check if backup dir exists
    if [[ ! -d $dir ]]; then
        cmd "mkdir -p $dir"
        retval="$?"
    fi

    return $retval
}

backupFile()
{
    local original=$1
    local backup=$2
    local retval=0

    # If original file exists, copy it to backup dir
    if [[ -e $original ]]; then
        cmd "cp $original $backup"
        retval=$?
    fi

    return $retval
}

installDotfile()
{
    local dotfileName="$1"
    local dotfileHomePath="$2"
    local dotfile=""
    local nested=0
    local now=`date +"%Y%m%d_%H%M"`
    local dotfilesSrcDir="/home/adam/archon/monolith/dotfiles"
    local dotfilesBkpDir="$dotfilesSrcDir/backup"

    # Avoid extra slash when path is empty
    if [[ -z "$dotfileHomePath" ]]; then
        dotfile="$dotfileName"
        nested=0
    else
        dotfile="$dotfileHomePath/$dotfileName"
        nested=1
    fi

    # Ensure that dotfiles backup dir exists
    createDir "$dotfilesBkpDir"
    retval="$?"
    if [[ $retval -ne 0  ]]; then
        log "$FUNCNAME: failed to create dotfiles backup dir: $retval"
        return 2
    fi

    # Backup original dotfile, if it exists
    backupFile "/home/adam/$dotfile" "$dotfilesBkpDir/$dotfile"_"$now"
    retval="$?"
    if [[ $retval -ne 0  ]]; then
        log "$FUNCNAME: failed to backup dotfile $dotfile: $retval"
        return 3
    fi

    # Remove original dotfile
    cmd "rm -f /home/adam/$dotfile"
    retval="$?"
    if [[ $retval -ne 0  ]]; then
        log "$FUNCNAME: failed to delete original dotfile"\
            " /home/adam/$dotfile: $retval"
        return 4
    fi

    # Ensure that for nested dotfile the path exists
    if [[ $nested -eq 1 ]]; then
        cmd "mkdir -p /home/adam/$dotfileHomePath"
        retval="$?"
        if [[ $retval -ne 0  ]]; then
            log "$FUNCNAME: failed to create path for nested dotfile: $retval"
            return 5
        fi
    fi

    # Create link to new dotfile
    createLink "$dotfilesSrcDir/$dotfile" "/home/adam/$dotfile"
    retval="$?"
    if [[ $retval -ne 0  ]]; then
        log "$FUNCNAME: failed to create link to new dotfile"\
            "$dotfilesSrcDir/$dotfile: $retval"
        return 6
    fi

    return $retval
}

changeOutputLevels()
{
    local src="StandardOutput=journal+console"
    local dst="StandardOutput=null\nStandardError=journal+console"
    local subst="s|$src|$dst|"
    local file="$1"

    cmd "sed -i \"$subst\" $file"
    err "$?" "$FUNCNAME" "failed to change output levels for $file"
}

# This function should be executed from regular user account (non-root).
# This is caused by makepkg not allowing for roor-account execution
installAurPackage()
{
    local buildDir="/tmp"
    local url="https://aur.archlinux.org/cgit/aur.git/snapshot"

    for p in $@
    do
        local pkgFile="$url/$p.tar.gz"

        cd $buildDir
        cmd "curl \"$pkgFile\" | tar xz"
        err "$?" "$FUNCNAME" "failed to download package file"

        cd $buildDir/$p
        err "$?" "$FUNCNAME" "failed to enter package dir"

        cmd "makepkg -si --noconfirm"
        err "$?" "$FUNCNAME" "failed to install package"
    done
}

